/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.js
var import_obsidian3 = require("obsidian");

// src/settings.js
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiProvider: "all",
  pexelsApiKey: "",
  pixabayApiKey: "",
  flickrApiKey: "",
  unsplashApiKey: "",
  imageSize: "medium",
  imageOrientation: "landscape",
  numberOfImages: 10,
  defaultKeywords: "nature, abstract, landscape, technology, art, cityscape, wildlife, ocean, mountains, forest, space, architecture, food, travel, science, music, sports, fashion, business, education, health, culture, history, weather, transportation, industry, people, animals, plants, patterns",
  yPosition: 50,
  // Update these fields to be arrays
  customBannerField: ["banner"],
  customYPositionField: ["banner-y"],
  customContentStartField: ["content-start"],
  customImageDisplayField: ["banner-display"],
  customImageRepeatField: ["banner-repeat"],
  folderImages: [],
  contentStartPosition: 150,
  imageDisplay: "cover",
  imageRepeat: false,
  bannerHeight: 350,
  customBannerHeightField: ["banner-height"],
  fade: -75,
  customFadeField: ["banner-fade"],
  borderRadius: 17,
  customBorderRadiusField: ["banner-radius"],
  showPinIcon: true,
  pinnedImageFolder: "pixel-banner-images",
  showReleaseNotes: true,
  lastVersion: null,
  showRefreshIcon: true,
  hidePixelBannerFields: false,
  hidePropertiesSectionIfOnlyBanner: false
};
var FolderSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app2, onChoose) {
    super(app2);
    this.onChoose = onChoose;
  }
  getItems() {
    return this.app.vault.getAllLoadedFiles().filter((file) => file.children).map((folder) => folder.path);
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item) {
    this.onChoose(item);
  }
};
var FolderImageSetting = class extends import_obsidian.Setting {
  constructor(containerEl, plugin, folderImage, index, onDelete) {
    super(containerEl);
    this.plugin = plugin;
    this.folderImage = folderImage;
    this.index = index;
    this.onDelete = onDelete;
    this.setClass("folder-image-setting");
    this.settingEl.empty();
    const folderImageDeleteContainer = this.settingEl.createDiv("folder-image-delete-container");
    this.addDeleteButton(folderImageDeleteContainer);
    const infoEl = this.settingEl.createDiv("setting-item-info");
    infoEl.createDiv("setting-item-name");
    infoEl.createDiv("setting-item-description");
    this.addFolderInput();
    this.addImageInput();
    this.addImageDisplaySettings();
    this.addYPostionAndContentStart();
    this.addFadeAndBannerHeight();
    const controlEl = this.settingEl.createDiv("setting-item-control full-width-control");
    this.addBorderRadiusInput(controlEl);
    this.addDirectChildrenOnlyToggle();
  }
  addDeleteButton(containerEl) {
    const deleteButton = containerEl.createEl("button", { cls: "pixel-banner-setting--delete-button" });
    deleteButton.style.marginLeft = "20px";
    deleteButton.style.width = "30px";
    deleteButton.style.height = "30px";
    deleteButton.style.padding = "0";
    deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-trash-2"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
    deleteButton.addEventListener("click", async () => {
      this.plugin.settings.folderImages.splice(this.index, 1);
      await this.plugin.saveSettings();
      this.settingEl.remove();
      if (this.onDelete) {
        this.onDelete();
      }
    });
  }
  addFolderInput() {
    const folderInputContainer = this.settingEl.createDiv("folder-input-container");
    const folderInput = new import_obsidian.Setting(folderInputContainer).setName("folder path").addText((text) => {
      text.setValue(this.folderImage.folder || "").onChange(async (value) => {
        this.folderImage.folder = value;
        await this.plugin.saveSettings();
      });
      this.folderInputEl = text.inputEl;
      this.folderInputEl.style.width = "300px";
    });
    folderInput.addButton((button) => button.setButtonText("Browse").onClick(() => {
      new FolderSuggestModal(this.plugin.app, (chosenPath) => {
        this.folderImage.folder = chosenPath;
        this.folderInputEl.value = chosenPath;
        this.plugin.saveSettings();
      }).open();
    }));
  }
  addImageInput() {
    const folderInputContainer = this.settingEl.createDiv("folder-input-container");
    const imageInput = new import_obsidian.Setting(folderInputContainer).setName("image url or keyword").addText((text) => {
      text.setValue(this.folderImage.image || "").onChange(async (value) => {
        this.folderImage.image = value;
        await this.plugin.saveSettings();
      });
      this.imageInputEl = text.inputEl;
      this.imageInputEl.style.width = "306px";
    });
  }
  addImageDisplaySettings(containerEl) {
    const displayContainer = this.settingEl.createDiv("display-and-repeat-container");
    const displaySetting = new import_obsidian.Setting(displayContainer).setName("image display").addDropdown((dropdown) => {
      dropdown.addOption("auto", "Auto").addOption("cover", "Cover").addOption("contain", "Contain").setValue(this.folderImage.imageDisplay || "cover").onChange(async (value) => {
        this.folderImage.imageDisplay = value;
        await this.plugin.saveSettings();
      });
      dropdown.selectEl.style.marginRight = "20px";
    });
    const repeatSetting = new import_obsidian.Setting(displayContainer).setName("repeat").addToggle((toggle) => {
      toggle.setValue(this.folderImage.imageRepeat || false).onChange(async (value) => {
        this.folderImage.imageRepeat = value;
        await this.plugin.saveSettings();
      });
    });
    const toggleEl = repeatSetting.controlEl.querySelector(".checkbox-container");
    if (toggleEl) toggleEl.style.justifyContent = "flex-start";
  }
  addYPostionAndContentStart() {
    const controlEl = this.settingEl.createDiv("setting-item-control full-width-control");
    this.addYPositionInput(controlEl);
    this.addContentStartInput(controlEl);
  }
  addFadeAndBannerHeight() {
    const controlEl = this.settingEl.createDiv("setting-item-control full-width-control");
    this.addFadeInput(controlEl);
    this.addBannerHeightInput(controlEl);
  }
  addYPositionInput(containerEl) {
    const label = containerEl.createEl("label", { text: "y-position", cls: "setting-item-name__label" });
    const sliderContainer = containerEl.createEl("div", { cls: "slider-container" });
    const slider = sliderContainer.createEl("input", {
      type: "range",
      cls: "slider",
      attr: {
        min: "0",
        max: "100",
        step: "1"
      }
    });
    slider.value = this.folderImage.yPosition || "50";
    slider.style.width = "100px";
    slider.style.marginLeft = "10px";
    const valueDisplay = sliderContainer.createEl("div", { cls: "slider-value" });
    valueDisplay.style.marginLeft = "10px";
    const updateValueDisplay = (value) => {
      valueDisplay.textContent = value;
    };
    updateValueDisplay(slider.value);
    slider.addEventListener("input", (event) => {
      updateValueDisplay(event.target.value);
    });
    slider.addEventListener("change", async () => {
      this.folderImage.yPosition = parseInt(slider.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(sliderContainer);
    containerEl.appendChild(label);
  }
  addContentStartInput(containerEl) {
    const label = containerEl.createEl("label", { text: "content start", cls: "setting-item-name__label" });
    label.style.marginLeft = "20px";
    const contentStartInput = containerEl.createEl("input", {
      type: "number",
      attr: {
        min: "0"
      }
    });
    contentStartInput.style.width = "50px";
    contentStartInput.style.marginLeft = "10px";
    contentStartInput.value = this.folderImage.contentStartPosition || "150";
    contentStartInput.addEventListener("change", async () => {
      this.folderImage.contentStartPosition = parseInt(contentStartInput.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(contentStartInput);
    containerEl.appendChild(label);
  }
  addBannerHeightInput(containerEl) {
    const label = containerEl.createEl("label", { text: "banner height", cls: "setting-item-name__label" });
    label.style.marginLeft = "20px";
    const heightInput = containerEl.createEl("input", {
      type: "number",
      attr: {
        min: "100",
        max: "2500"
      }
    });
    heightInput.style.width = "50px";
    heightInput.style.marginLeft = "10px";
    heightInput.value = this.folderImage.bannerHeight || "";
    heightInput.placeholder = String(this.plugin.settings.bannerHeight || 350);
    heightInput.addEventListener("change", async () => {
      let value = heightInput.value ? parseInt(heightInput.value) : null;
      if (value !== null) {
        value = Math.max(100, Math.min(2500, value));
        this.folderImage.bannerHeight = value;
        heightInput.value = value;
      } else {
        delete this.folderImage.bannerHeight;
        heightInput.value = "";
      }
      await this.plugin.saveSettings();
    });
    label.appendChild(heightInput);
    containerEl.appendChild(label);
  }
  addFadeInput(containerEl) {
    const label = containerEl.createEl("label", { text: "fade", cls: "setting-item-name__label" });
    const sliderContainer = containerEl.createEl("div", { cls: "slider-container" });
    const slider = sliderContainer.createEl("input", {
      type: "range",
      cls: "slider",
      attr: {
        min: "-1500",
        max: "100",
        step: "5"
      }
    });
    slider.value = this.folderImage.fade !== void 0 ? this.folderImage.fade : "-75";
    slider.style.width = "100px";
    slider.style.marginLeft = "10px";
    const valueDisplay = sliderContainer.createEl("div", { cls: "slider-value" });
    valueDisplay.style.marginLeft = "10px";
    const updateValueDisplay = (value) => {
      valueDisplay.textContent = value;
    };
    updateValueDisplay(slider.value);
    slider.addEventListener("input", (event) => {
      updateValueDisplay(event.target.value);
    });
    slider.addEventListener("change", async () => {
      this.folderImage.fade = parseInt(slider.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(sliderContainer);
    containerEl.appendChild(label);
  }
  // Add this method
  addDirectChildrenOnlyToggle() {
    new import_obsidian.Setting(this.settingEl).setName("Direct Children Only").setDesc("Apply banner only to direct children of the folder").addToggle((toggle) => {
      toggle.setValue(this.folderImage.directChildrenOnly || false).onChange(async (value) => {
        this.folderImage.directChildrenOnly = value;
        await this.plugin.saveSettings();
      });
    });
  }
  // In FolderImageSetting class, add this method
  addBorderRadiusInput(containerEl) {
    var _a;
    const label = containerEl.createEl("label", { text: "border radius", cls: "setting-item-name__label" });
    const radiusInput = containerEl.createEl("input", {
      type: "number",
      attr: {
        min: "0",
        max: "50"
      }
    });
    radiusInput.style.width = "50px";
    radiusInput.style.marginLeft = "10px";
    radiusInput.value = (_a = this.folderImage.borderRadius) != null ? _a : "";
    radiusInput.placeholder = String(this.plugin.settings.borderRadius || 17);
    radiusInput.addEventListener("change", async () => {
      let value = radiusInput.value ? parseInt(radiusInput.value) : null;
      if (value !== null) {
        value = Math.max(0, Math.min(50, value));
        this.folderImage.borderRadius = value;
        radiusInput.value = String(value);
      } else {
        delete this.folderImage.borderRadius;
        radiusInput.value = "";
      }
      await this.plugin.saveSettings();
    });
    label.appendChild(radiusInput);
    containerEl.appendChild(label);
  }
};
function arrayToString(arr) {
  return Array.isArray(arr) ? arr.join(", ") : arr;
}
function stringToArray(str) {
  return str.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
}
function validateFieldNames(settings, allFields, currentField, newNames) {
  const validNamePattern = /^[a-zA-Z0-9_-]+$/;
  const invalidNames = newNames.filter((name) => !validNamePattern.test(name));
  if (invalidNames.length > 0) {
    return {
      isValid: false,
      message: `Invalid characters in field names (only letters, numbers, dashes, and underscores allowed): ${invalidNames.join(", ")}`
    };
  }
  const otherFields = allFields.filter((f) => f !== currentField);
  const otherFieldNames = otherFields.flatMap((f) => settings[f]);
  const duplicates = newNames.filter((name) => otherFieldNames.includes(name));
  if (duplicates.length > 0) {
    return {
      isValid: false,
      message: `Duplicate field names found: ${duplicates.join(", ")}`
    };
  }
  return { isValid: true };
}
var PixelBannerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("pixel-banner-settings");
    const mainContent = containerEl.createEl("div", { cls: "pixel-banner-main-content" });
    const { tabsEl, tabContentContainer } = this.createTabs(mainContent, [
      "General",
      "Custom Field Names",
      "API Settings",
      "Folder Images",
      "Examples"
    ]);
    const generalTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "General" } });
    this.createGeneralSettings(generalTab);
    const customFieldsTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Custom Field Names" } });
    this.createCustomFieldsSettings(customFieldsTab);
    const apiTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "API Settings" } });
    this.createAPISettings(apiTab);
    const foldersTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Folder Images" } });
    this.createFolderSettings(foldersTab);
    const examplesTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Examples" } });
    this.createExampleSettings(examplesTab);
    tabsEl.firstChild.click();
  }
  createTabs(containerEl, tabNames) {
    const tabsEl = containerEl.createEl("div", { cls: "pixel-banner-settings-tabs" });
    const tabContentContainer = containerEl.createEl("div", { cls: "pixel-banner-settings-tab-content-container" });
    tabNames.forEach((tabName) => {
      const tabEl = tabsEl.createEl("button", { cls: "pixel-banner-settings-tab", text: tabName });
      tabEl.addEventListener("click", () => {
        tabsEl.querySelectorAll(".pixel-banner-settings-tab").forEach((tab) => tab.removeClass("active"));
        tabContentContainer.querySelectorAll(".tab-content").forEach((content) => content.style.display = "none");
        tabEl.addClass("active");
        tabContentContainer.querySelector(`.tab-content[data-tab="${tabName}"]`).style.display = "flex";
      });
    });
    return { tabsEl, tabContentContainer };
  }
  createAPISettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: "Optionally select which API provider to use for fetching images. See the Examples tab for more information on referencing images by URL or local image. You can use any combination of API keyword, URL, or local image between notes." });
    new import_obsidian.Setting(containerEl).setName("API Provider").setDesc("Select the API provider for fetching images").addDropdown((dropdown) => dropdown.addOption("all", "All (Random)").addOption("pexels", "Pexels").addOption("pixabay", "Pixabay").addOption("flickr", "Flickr").addOption("unsplash", "Unsplash").setValue(this.plugin.settings.apiProvider).onChange(async (value) => {
      this.plugin.settings.apiProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian.Setting(containerEl).setName("Pexels API Key");
    containerEl.createEl("span", { text: "Enter your Pexels API key. Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://www.pexels.com/api/", text: "Pexels API" });
    const pexelsApiKeySetting = new import_obsidian.Setting(containerEl).setClass("full-width-control").addText((text) => {
      text.setPlaceholder("Pexels API key").setValue(this.plugin.settings.pexelsApiKey).onChange(async (value) => {
        this.plugin.settings.pexelsApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "calc(100% - 100px)";
    }).addButton((button) => button.setButtonText("Test API").onClick(async () => {
      const apiKey = this.plugin.settings.pexelsApiKey;
      if (!apiKey) {
        new Notice("Please enter an API key first");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      const isValid = await testPexelsApi(apiKey);
      button.setButtonText("Test API");
      button.setDisabled(false);
      new Notice(isValid ? "\u2705 Pexels API key is valid!" : "\u274C Invalid Pexels API key");
    }));
    pexelsApiKeySetting.settingEl.style.width = "100%";
    new import_obsidian.Setting(containerEl).setName("Pixabay API Key");
    containerEl.createEl("span", { text: "Enter your Pixabay API key. Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://pixabay.com/api/docs/", text: "Pixabay API" });
    const pixabayApiKeySetting = new import_obsidian.Setting(containerEl).setClass("full-width-control").addText((text) => {
      text.setPlaceholder("Pixabay API key").setValue(this.plugin.settings.pixabayApiKey).onChange(async (value) => {
        this.plugin.settings.pixabayApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "calc(100% - 100px)";
    }).addButton((button) => button.setButtonText("Test API").onClick(async () => {
      const apiKey = this.plugin.settings.pixabayApiKey;
      if (!apiKey) {
        new Notice("Please enter an API key first");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      const isValid = await testPixabayApi(apiKey);
      button.setButtonText("Test API");
      button.setDisabled(false);
      new Notice(isValid ? "\u2705 Pixabay API key is valid!" : "\u274C Invalid Pixabay API key");
    }));
    pixabayApiKeySetting.settingEl.style.width = "100%";
    new import_obsidian.Setting(containerEl).setName("Flickr API Key");
    containerEl.createEl("span", { text: "Enter your Flickr API key. Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://www.flickr.com/services/api/", text: "Flickr API" });
    const flickrApiKeySetting = new import_obsidian.Setting(containerEl).setClass("full-width-control").addText((text) => {
      text.setPlaceholder("Flickr API key").setValue(this.plugin.settings.flickrApiKey).onChange(async (value) => {
        this.plugin.settings.flickrApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "calc(100% - 100px)";
    }).addButton((button) => button.setButtonText("Test API").onClick(async () => {
      const apiKey = this.plugin.settings.flickrApiKey;
      if (!apiKey) {
        new Notice("Please enter an API key first");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      const isValid = await testFlickrApi(apiKey);
      button.setButtonText("Test API");
      button.setDisabled(false);
      new Notice(isValid ? "\u2705 Flickr API key is valid!" : "\u274C Invalid Flickr API key");
    }));
    new import_obsidian.Setting(containerEl).setName("Unsplash API Key");
    containerEl.createEl("span", { text: "Enter your Unsplash API key (Access Key). Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://unsplash.com/oauth/applications", text: "Unsplash API" });
    const unsplashApiKeySetting = new import_obsidian.Setting(containerEl).setClass("full-width-control").addText((text) => {
      text.setPlaceholder("Unsplash API key").setValue(this.plugin.settings.unsplashApiKey).onChange(async (value) => {
        this.plugin.settings.unsplashApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "calc(100% - 100px)";
    }).addButton((button) => button.setButtonText("Test API").onClick(async () => {
      const apiKey = this.plugin.settings.unsplashApiKey;
      if (!apiKey) {
        new Notice("Please enter an API key first");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      const isValid = await testUnsplashApi(apiKey);
      button.setButtonText("Test API");
      button.setDisabled(false);
      new Notice(isValid ? "\u2705 Unsplash API key is valid!" : "\u274C Invalid Unsplash API key");
    }));
    new import_obsidian.Setting(containerEl).setName("Images").setDesc("Configure settings for images fetched from API. These settings apply when using keywords to fetch random images.").setHeading();
    new import_obsidian.Setting(containerEl).setName("Show Pin Icon").setDesc("Show a pin icon on random banner images that allows saving them to your vault. Once pinned, your frontmatter will be updated to use the local image instead of the API image.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showPinIcon).onChange(async (value) => {
      this.plugin.settings.showPinIcon = value;
      folderInputSetting.settingEl.style.display = value ? "flex" : "none";
      refreshIconSetting.settingEl.style.display = value ? "flex" : "none";
      await this.plugin.saveSettings();
    }));
    const folderInputSetting = new import_obsidian.Setting(containerEl).setName("Pinned Images Folder").setDesc("Default folder where pinned banner images will be saved").addText((text) => {
      text.setPlaceholder("pixel-banner-images").setValue(this.plugin.settings.pinnedImageFolder).onChange(async (value) => {
        this.plugin.settings.pinnedImageFolder = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.addEventListener("blur", async () => {
        let value = text.inputEl.value.trim();
        if (!value) {
          value = "pixel-banner-images";
        }
        text.setValue(value);
        this.plugin.settings.pinnedImageFolder = value;
        await this.plugin.saveSettings();
      });
      return text;
    }).addButton((button) => button.setButtonText("Clean Orphaned Pins").setTooltip("Remove pinned images from the default folder that are no longer referenced in Notes").onClick(async () => {
      button.setButtonText("\u{1FAE7} Cleaning...");
      button.setDisabled(true);
      try {
        const result = await this.plugin.cleanOrphanedPins();
        new Notice(`\u{1F9FC} Cleaned ${result.cleaned} orphaned pinned images`);
      } catch (error) {
        console.error("Error cleaning orphaned pins:", error);
        new Notice("Failed to clean orphaned pins");
      } finally {
        button.setButtonText("Clean Orphaned Pins");
        button.setDisabled(false);
      }
    }));
    const refreshIconSetting = new import_obsidian.Setting(containerEl).setName("Show Refresh Icon").setDesc("Show a refresh icon next to the pin icon to get a new random image").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRefreshIcon).onChange(async (value) => {
      this.plugin.settings.showRefreshIcon = value;
      await this.plugin.saveSettings();
    }));
    folderInputSetting.settingEl.style.display = this.plugin.settings.showPinIcon ? "flex" : "none";
    refreshIconSetting.settingEl.style.display = this.plugin.settings.showPinIcon ? "flex" : "none";
    new import_obsidian.Setting(containerEl).setName("Size").setDesc("Select the size of the image - (API only)").addDropdown((dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.plugin.settings.imageSize).onChange(async (value) => {
      this.plugin.settings.imageSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Orientation").setDesc("Select the orientation of the image - (API only)").addDropdown((dropdown) => dropdown.addOption("landscape", "Landscape").addOption("portrait", "Portrait").addOption("square", "Square").setValue(this.plugin.settings.imageOrientation).onChange(async (value) => {
      this.plugin.settings.imageOrientation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Number of images").setDesc("Enter the number of random images to fetch (3-50) - (API only)").addText((text) => text.setPlaceholder("10").setValue(String(this.plugin.settings.numberOfImages || 10)).onChange(async (value) => {
      let numValue = Number(value);
      if (!isNaN(numValue)) {
        numValue = Math.max(3, Math.min(numValue, 50));
        this.plugin.settings.numberOfImages = numValue;
        await this.plugin.saveSettings();
      }
    })).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      inputEl.type = "number";
      inputEl.min = "3";
      inputEl.max = "50";
      inputEl.style.width = "50px";
    });
    const defaultKeywordsSetting = new import_obsidian.Setting(containerEl).setName("Default keywords").setDesc("Enter a comma-separated list of default keywords to be used when no keyword is provided in the frontmatter, or when the provided keyword does not return any results. - (API only)").addTextArea((text) => {
      text.setPlaceholder("Enter keywords, separated by commas").setValue(this.plugin.settings.defaultKeywords).onChange(async (value) => {
        this.plugin.settings.defaultKeywords = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "100%";
      text.inputEl.style.marginTop = "15px";
      text.inputEl.style.height = "90px";
    }).addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.defaultKeywords = DEFAULT_SETTINGS.defaultKeywords;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    defaultKeywordsSetting.settingEl.dataset.id = "defaultKeywords";
    defaultKeywordsSetting.settingEl.style.display = "flex";
    defaultKeywordsSetting.settingEl.style.flexDirection = "column";
  }
  createGeneralSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: "Set the default vertical position of the image, how it should be displayed, and where the content should start. These are global settings and apply to all notes with banners unless overridden by folder or note-specific settings." });
    new import_obsidian.Setting(containerEl).setName("Image Vertical Position").setDesc("Set the vertical position of the image (0-100)").addSlider(
      (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.yPosition).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.yPosition = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      })
    ).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.yPosition = DEFAULT_SETTINGS.yPosition;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const sliderEl = button.extraSettingsEl.parentElement.querySelector(".slider");
      sliderEl.value = DEFAULT_SETTINGS.yPosition;
      sliderEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Content Start Position").setDesc("Set the default vertical position where the content starts (in pixels)").addText((text) => text.setPlaceholder("150").setValue(String(this.plugin.settings.contentStartPosition)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue >= 0) {
        this.plugin.settings.contentStartPosition = numValue;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      }
    })).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      inputEl.type = "number";
      inputEl.min = "0";
      inputEl.style.width = "60px";
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.contentStartPosition = DEFAULT_SETTINGS.contentStartPosition;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const inputEl = button.extraSettingsEl.parentElement.querySelector("input");
      inputEl.value = DEFAULT_SETTINGS.contentStartPosition;
      inputEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Image Display").setDesc("Set how the banner image should be displayed").addDropdown((dropdown) => {
      dropdown.addOption("auto", "Auto").addOption("cover", "Cover").addOption("contain", "Contain").setValue(this.plugin.settings.imageDisplay || "cover").onChange(async (value) => {
        this.plugin.settings.imageDisplay = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      });
      return dropdown;
    }).addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.imageDisplay = DEFAULT_SETTINGS.imageDisplay;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
        const dropdownEl = button.extraSettingsEl.parentElement.querySelector("select");
        dropdownEl.value = DEFAULT_SETTINGS.imageDisplay;
        dropdownEl.dispatchEvent(new Event("change"));
      });
      return button;
    });
    new import_obsidian.Setting(containerEl).setName("Image Repeat").setDesc('Enable image repetition when "Contain" is selected').addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.imageRepeat).onChange(async (value) => {
        this.plugin.settings.imageRepeat = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      });
      return toggle;
    }).addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.imageRepeat = DEFAULT_SETTINGS.imageRepeat;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
        const checkboxContainer = button.extraSettingsEl.parentElement.querySelector(".checkbox-container");
        const toggleEl = checkboxContainer.querySelector("input");
        if (toggleEl) {
          toggleEl.checked = DEFAULT_SETTINGS.imageRepeat;
          checkboxContainer.classList.toggle("is-enabled", DEFAULT_SETTINGS.imageRepeat);
          const event = new Event("change", { bubbles: true });
          toggleEl.dispatchEvent(event);
        }
      });
      return button;
    });
    new import_obsidian.Setting(containerEl).setName("Banner Height").setDesc("Set the default height of the banner image (100-2500 pixels)").addText((text) => {
      text.setPlaceholder("350").setValue(String(this.plugin.settings.bannerHeight)).onChange(async (value) => {
        if (value === "" || !isNaN(Number(value))) {
          await this.plugin.saveSettings();
        }
      });
      text.inputEl.addEventListener("blur", async (event) => {
        let numValue = Number(event.target.value);
        if (isNaN(numValue) || event.target.value === "") {
          numValue = 350;
        } else {
          numValue = Math.max(100, Math.min(2500, numValue));
        }
        this.plugin.settings.bannerHeight = numValue;
        text.setValue(String(numValue));
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      });
      text.inputEl.type = "number";
      text.inputEl.min = "100";
      text.inputEl.max = "2500";
      text.inputEl.style.width = "50px";
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.bannerHeight = DEFAULT_SETTINGS.bannerHeight;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const inputEl = button.extraSettingsEl.parentElement.querySelector("input");
      inputEl.value = DEFAULT_SETTINGS.bannerHeight;
      inputEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Banner Fade").setDesc("Set the default fade effect for the banner image (-1500 to 100)").addSlider(
      (slider) => slider.setLimits(-1500, 100, 5).setValue(this.plugin.settings.fade).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.fade = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      })
    ).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.fade = DEFAULT_SETTINGS.fade;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const sliderEl = button.extraSettingsEl.parentElement.querySelector(".slider");
      sliderEl.value = DEFAULT_SETTINGS.fade;
      sliderEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Border Radius").setDesc("Set the default border radius of the banner image (0-50 pixels)").addText((text) => {
      text.setPlaceholder("17").setValue(String(this.plugin.settings.borderRadius)).onChange(async (value) => {
        const numValue = Number(value);
        if (!isNaN(numValue)) {
          this.plugin.settings.borderRadius = Math.max(0, Math.min(50, numValue));
          await this.plugin.saveSettings();
          this.plugin.updateAllBanners();
        }
      });
      text.inputEl.type = "number";
      text.inputEl.min = "0";
      text.inputEl.max = "50";
      text.inputEl.style.width = "50px";
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.borderRadius = DEFAULT_SETTINGS.borderRadius;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const inputEl = button.extraSettingsEl.parentElement.querySelector("input");
      inputEl.value = DEFAULT_SETTINGS.borderRadius;
      inputEl.dispatchEvent(new Event("input"));
    }));
    const hidePixelBannerFieldsSetting = new import_obsidian.Setting(containerEl).setName("Hide Pixel Banner Fields").setDesc("Hide banner-related frontmatter fields in Reading mode").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.hidePixelBannerFields).onChange(async (value) => {
        this.plugin.settings.hidePixelBannerFields = value;
        if (!value) {
          this.plugin.settings.hidePropertiesSectionIfOnlyBanner = false;
          const dependentToggle = hidePropertiesSection.components[0];
          if (dependentToggle) {
            dependentToggle.setValue(false);
            dependentToggle.setDisabled(true);
          }
          this.app.workspace.iterateAllLeaves((leaf) => {
            if (leaf.view instanceof import_obsidian.MarkdownView && leaf.view.contentEl) {
              const propertiesContainer = leaf.view.contentEl.querySelector(".metadata-container");
              if (propertiesContainer) {
                propertiesContainer.classList.remove("pixel-banner-hidden-section");
                const hiddenFields = propertiesContainer.querySelectorAll(".pixel-banner-hidden-field");
                hiddenFields.forEach((field) => {
                  field.classList.remove("pixel-banner-hidden-field");
                });
              }
            }
          });
        } else {
          const dependentToggle = hidePropertiesSection.components[0];
          if (dependentToggle) {
            dependentToggle.setDisabled(false);
          }
        }
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      });
      return toggle;
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.hidePixelBannerFields = DEFAULT_SETTINGS.hidePixelBannerFields;
      this.plugin.settings.hidePropertiesSectionIfOnlyBanner = DEFAULT_SETTINGS.hidePropertiesSectionIfOnlyBanner;
      await this.plugin.saveSettings();
      const mainToggle = hidePixelBannerFieldsSetting.components[0];
      if (mainToggle) {
        mainToggle.setValue(DEFAULT_SETTINGS.hidePixelBannerFields);
      }
      const dependentToggle = hidePropertiesSection.components[0];
      if (dependentToggle) {
        dependentToggle.setValue(DEFAULT_SETTINGS.hidePropertiesSectionIfOnlyBanner);
        dependentToggle.setDisabled(!DEFAULT_SETTINGS.hidePixelBannerFields);
      }
      this.plugin.updateAllBanners();
    }));
    const hidePropertiesSection = new import_obsidian.Setting(containerEl).setName("Hide Properties Section").setDesc("Hide the entire Properties section in Reading mode if it only contains Pixel Banner fields").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.hidePropertiesSectionIfOnlyBanner).setDisabled(!this.plugin.settings.hidePixelBannerFields).onChange(async (value) => {
        this.plugin.settings.hidePropertiesSectionIfOnlyBanner = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      });
      return toggle;
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.hidePropertiesSectionIfOnlyBanner = DEFAULT_SETTINGS.hidePropertiesSectionIfOnlyBanner;
      await this.plugin.saveSettings();
      const toggle = hidePropertiesSection.components[0];
      if (toggle) {
        toggle.setValue(DEFAULT_SETTINGS.hidePropertiesSectionIfOnlyBanner);
      }
      this.plugin.updateAllBanners();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Release Notes").setDesc("Show release notes after plugin updates").addToggle((toggle) => toggle.setValue(this.plugin.settings.showReleaseNotes).onChange(async (value) => {
      this.plugin.settings.showReleaseNotes = value;
      await this.plugin.saveSettings();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.showReleaseNotes = DEFAULT_SETTINGS.showReleaseNotes;
      await this.plugin.saveSettings();
      const toggleEl = button.extraSettingsEl.parentElement.querySelector(".checkbox-container input");
      if (toggleEl) {
        toggleEl.checked = DEFAULT_SETTINGS.showReleaseNotes;
        toggleEl.dispatchEvent(new Event("change"));
      }
    }));
  }
  createCustomFieldsSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: 'Customize the frontmatter field names used for the banner and Y-position. You can define multiple names for each field, separated by commas. Field names can only contain letters, numbers, dashes, and underscores. Example: "banner, pixel-banner, header_image" could all be used as the banner field name.' });
    const customFields = [
      {
        setting: "customBannerField",
        name: "Banner Field Names",
        desc: "Set custom field names for the banner in frontmatter (comma-separated)",
        placeholder: "banner, pixel-banner, header-image"
      },
      {
        setting: "customYPositionField",
        name: "Y-Position Field Names",
        desc: "Set custom field names for the Y-position in frontmatter (comma-separated)",
        placeholder: "banner-y, y-position, banner-offset"
      },
      {
        setting: "customContentStartField",
        name: "Content Start Position Field Names",
        desc: "Set custom field names for the content start position in frontmatter (comma-separated)",
        placeholder: "content-start, start-position, content-offset"
      },
      {
        setting: "customImageDisplayField",
        name: "Image Display Field Names",
        desc: "Set custom field names for the image display in frontmatter (comma-separated)",
        placeholder: "banner-display, image-display, display-mode"
      },
      {
        setting: "customImageRepeatField",
        name: "Image Repeat Field Names",
        desc: "Set custom field names for the image repeat in frontmatter (comma-separated)",
        placeholder: "banner-repeat, image-repeat, repeat-image"
      },
      {
        setting: "customBannerHeightField",
        name: "Banner Height Field Names",
        desc: "Set custom field names for the banner height in frontmatter (comma-separated)",
        placeholder: "banner-height, image-height, header-height"
      },
      {
        setting: "customFadeField",
        name: "Fade Field Names",
        desc: "Set custom field names for the fade effect in frontmatter (comma-separated)",
        placeholder: "banner-fade, fade-effect, image-fade"
      },
      {
        setting: "customBorderRadiusField",
        name: "Border Radius Field Names",
        desc: "Set custom field names for the border radius in frontmatter (comma-separated)",
        placeholder: "banner-radius, border-radius, banner-corner-radius"
      }
    ];
    customFields.forEach((field) => {
      new import_obsidian.Setting(containerEl).setName(field.name).setDesc(field.desc).addText((text) => {
        text.setPlaceholder(field.placeholder).setValue(arrayToString(this.plugin.settings[field.setting])).onChange(async (value) => {
          const newNames = stringToArray(value);
          const validation = validateFieldNames(
            this.plugin.settings,
            customFields.map((f) => f.setting),
            field.setting,
            newNames
          );
          if (validation.isValid) {
            this.plugin.settings[field.setting] = newNames;
            await this.plugin.saveSettings();
          } else {
            new Notice(validation.message);
            text.setValue(arrayToString(this.plugin.settings[field.setting]));
          }
        });
        text.inputEl.style.width = "220px";
      }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings[field.setting] = DEFAULT_SETTINGS[field.setting];
        await this.plugin.saveSettings();
        const settingEl = button.extraSettingsEl.parentElement;
        const textInput = settingEl.querySelector('input[type="text"]');
        textInput.value = arrayToString(DEFAULT_SETTINGS[field.setting]);
        const event = new Event("input", { bubbles: true, cancelable: true });
        textInput.dispatchEvent(event);
      }));
    });
  }
  createFolderSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: 'Set default banner images for specific folders. These will apply to all notes in the folder unless overridden by note-specific settings. To get started, add a folder image setting and click the "+ Add Folder Image Setting" button below.' });
    const folderImagesContainer = containerEl.createDiv("folder-images-container");
    const updateFolderSettings = () => {
      var _a, _b;
      folderImagesContainer.empty();
      const sortedFolderImages = [...this.plugin.settings.folderImages].sort((a, b) => {
        const folderA = (a.folder || "").toLowerCase();
        const folderB = (b.folder || "").toLowerCase();
        return folderA.localeCompare(folderB);
      });
      this.plugin.settings.folderImages = sortedFolderImages;
      const folderSettings = sortedFolderImages.map(
        (folderImage, index) => new FolderImageSetting(folderImagesContainer, this.plugin, folderImage, index, updateFolderSettings)
      );
      if (this.shouldFocusNewFolder) {
        (_b = (_a = folderSettings[0]) == null ? void 0 : _a.folderInputEl) == null ? void 0 : _b.focus();
        this.shouldFocusNewFolder = false;
      }
    };
    updateFolderSettings();
    const addFolderContainer = containerEl.createDiv("add-folder-image-setting");
    new import_obsidian.Setting(addFolderContainer).addButton((button) => button.setButtonText("+ Add Folder Image Setting").onClick(async () => {
      this.plugin.settings.folderImages.push({ folder: "", image: "", yPosition: 50, contentStartPosition: 150 });
      await this.plugin.saveSettings();
      this.shouldFocusNewFolder = true;
      updateFolderSettings();
    }));
  }
  createExampleSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("How to use").setHeading().settingEl.querySelector(".setting-item-name").style.cssText = "color: var(--text-accent-hover); font-size: var(--font-ui-large);";
    const getRandomFieldName = (fieldNames) => {
      const names = Array.isArray(fieldNames) ? fieldNames : [fieldNames];
      return names[Math.floor(Math.random() * names.length)];
    };
    const instructionsEl = containerEl.createEl("div", { cls: "pixel-banner-section" });
    instructionsEl.createEl("p", { text: "Add the following fields to your note's frontmatter to customize the banner:" });
    const codeEl = instructionsEl.createEl("pre");
    codeEl.createEl("code", {
      text: `---
${getRandomFieldName(this.plugin.settings.customBannerField)}: blue turtle
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 30
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 200
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: contain
${getRandomFieldName(this.plugin.settings.customImageRepeatField)}: true
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 400
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 25
---

# Or use a direct URL:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: https://example.com/image.jpg
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 70
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 180
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: cover
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 300
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 0
---

# Or use a path to an image in the vault:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: Assets/my-image.png
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 0
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 100
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: auto
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 250
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 50
---

# Or use an Obsidian internal link:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: [[example-image.png]]
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 100
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 50
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: contain
${getRandomFieldName(this.plugin.settings.customImageRepeatField)}: false
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 500
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 17
---`
    });
    instructionsEl.createEl("p", { text: 'Note: The image display options are "auto", "cover", or "contain". The image repeat option is only applicable when the display is set to "contain".' });
    containerEl.createEl("img", {
      attr: {
        src: "https://raw.githubusercontent.com/jparkerweb/pixel-banner/main/example.jpg",
        alt: "Example of a Pixel banner",
        style: "max-width: 100%; height: auto; margin-top: 10px; border-radius: 5px;"
      }
    });
  }
  validateFieldName(value, otherFieldName) {
    if (value === otherFieldName) {
      new Notice("Field names must be unique!");
      return false;
    }
    return true;
  }
};
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
async function testPexelsApi(apiKey) {
  try {
    const response = await fetch("https://api.pexels.com/v1/search?query=dog&per_page=3", {
      headers: {
        "Authorization": apiKey
      }
    });
    if (!response.ok) {
      throw new Error("\u274C Invalid Pexels API key");
    }
    const data = await response.json();
    return data.photos && data.photos.length > 0;
  } catch (error) {
    return false;
  }
}
async function testPixabayApi(apiKey) {
  try {
    const response = await fetch(`https://pixabay.com/api/?key=${apiKey}&q=test&per_page=3`);
    const data = await response.json();
    if (data.error) {
      throw new Error(data.error);
    }
    return true;
  } catch (error) {
    return false;
  }
}
async function testFlickrApi(apiKey) {
  try {
    const response = await fetch(`https://www.flickr.com/services/rest/?method=flickr.test.echo&api_key=${apiKey}&format=json&nojsoncallback=1`);
    const data = await response.json();
    return data.stat === "ok";
  } catch (error) {
    return false;
  }
}
async function testUnsplashApi(apiKey) {
  try {
    const response = await fetch("https://api.unsplash.com/photos/random", {
      headers: {
        "Authorization": `Client-ID ${apiKey}`
      }
    });
    return response.ok;
  } catch (error) {
    return false;
  }
}

// src/modals.js
var import_obsidian2 = require("obsidian");
var ReleaseNotesModal = class extends import_obsidian2.Modal {
  constructor(app2, version, releaseNotes2) {
    super(app2);
    this.version = version;
    this.releaseNotes = releaseNotes2;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: `Welcome to \u{1F6A9} Pixel Banner v${this.version}` });
    contentEl.createEl("p", {
      text: "After each update you'll be prompted with the release notes. You can disable this in the plugin settings General tab.",
      cls: "release-notes-instructions"
    });
    const kofiContainer = contentEl.createEl("div");
    kofiContainer.style.textAlign = "right";
    const kofiLink = kofiContainer.createEl("a", {
      href: "https://ko-fi.com/Z8Z212UMBI",
      target: "_blank"
    });
    kofiLink.createEl("img", {
      attr: {
        height: "36",
        style: "border:0px;height:36px;",
        src: "https://raw.githubusercontent.com/jparkerweb/pixel-banner/refs/heads/main/img/support.png",
        border: "0",
        alt: "Buy Me a Coffee at ko-fi.com"
      }
    });
    const notesContainer = contentEl.createDiv("release-notes-container");
    notesContainer.innerHTML = this.releaseNotes;
    contentEl.createEl("div", { cls: "release-notes-spacer" }).style.height = "20px";
    new import_obsidian2.Setting(contentEl).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// virtual-module:virtual:release-notes
var releaseNotes = '<h2>\u{1F389} What&#39;s New</h2>\n<h3>v2.9.1</h3>\n<h4>Fixed</h4>\n<ul>\n<li>Fixed overaggressive banner API refresh when editor content changed</li>\n<li>Fixed Pexels API key test</li>\n</ul>\n<h3>v2.9.0</h3>\n<h4>Added</h4>\n<ul>\n<li>Option to Hide Pixel Banner property fields from displaying when in Reading Mode</li>\n<li>Option to Hide the Property Section from displaying in Reading Mode if the only fields are Pixel Banner fields</li>\n</ul>\n<p><img src="https://raw.githubusercontent.com/jparkerweb/pixel-banner/refs/heads/main/img/releases/pixel-banner-v2.9.0.jpg" alt="Ninja Fields"></p>\n';

// src/main.js
module.exports = class PixelBannerPlugin extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "debounceTimer", null);
    __publicField(this, "loadedImages", /* @__PURE__ */ new Map());
    __publicField(this, "lastKeywords", /* @__PURE__ */ new Map());
    __publicField(this, "imageCache", /* @__PURE__ */ new Map());
    __publicField(this, "rateLimiter", {
      lastRequestTime: 0,
      minInterval: 1e3
      // 1 second between requests
    });
    __publicField(this, "lastYPositions", /* @__PURE__ */ new Map());
    __publicField(this, "lastFrontmatter", /* @__PURE__ */ new Map());
    __publicField(this, "debouncedEnsureBanner", debounce(() => {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && activeLeaf.view instanceof import_obsidian3.MarkdownView) {
        this.updateBanner(activeLeaf.view, false);
      }
    }, 100));
  }
  async onload() {
    await this.loadSettings();
    await this.checkVersion();
    this.addSettingTab(new PixelBannerSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange.bind(this))
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", async (file) => {
        var _a;
        const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        if (!frontmatter) return;
        const previousFrontmatter = this.lastFrontmatter.get(file.path);
        if (JSON.stringify(frontmatter) === JSON.stringify(previousFrontmatter)) {
          return;
        }
        const relevantFields = [
          ...this.settings.customBannerField,
          ...this.settings.customYPositionField,
          ...this.settings.customContentStartField,
          ...this.settings.customImageDisplayField,
          ...this.settings.customImageRepeatField,
          ...this.settings.customBannerHeightField,
          ...this.settings.customFadeField,
          ...this.settings.customBorderRadiusField
        ];
        const hasRelevantFieldChange = relevantFields.some(
          (field) => frontmatter[field] !== (previousFrontmatter == null ? void 0 : previousFrontmatter[field])
        );
        if (!hasRelevantFieldChange) return;
        this.lastFrontmatter.set(file.path, frontmatter);
        const leaves = this.app.workspace.getLeavesOfType("markdown");
        for (const leaf of leaves) {
          if (leaf.view instanceof import_obsidian3.MarkdownView && leaf.view.file === file && !leaf.containerEl.style.display && leaf.containerEl.matches(".workspace-leaf")) {
            this.loadedImages.delete(file.path);
            this.lastKeywords.delete(file.path);
            await this.updateBanner(leaf.view, true);
          }
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", this.handleLayoutChange.bind(this))
    );
    this.registerEvent(
      this.app.workspace.on("mode-change", this.handleModeChange.bind(this))
    );
    this.registerMarkdownPostProcessor(this.postProcessor.bind(this));
    this.setupMutationObserver();
    this.addCommand({
      id: "pin-banner-image",
      name: "\u{1F4CC} Pin current banner image",
      checkCallback: (checking) => {
        var _a;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!activeView || !activeView.file) return false;
        const imageUrl = this.loadedImages.get(activeView.file.path);
        const frontmatter = (_a = this.app.metadataCache.getFileCache(activeView.file)) == null ? void 0 : _a.frontmatter;
        let bannerImage, usedField;
        for (const field of this.settings.customBannerField) {
          if (frontmatter == null ? void 0 : frontmatter[field]) {
            bannerImage = frontmatter[field];
            usedField = field;
            break;
          }
        }
        const inputType = this.getInputType(bannerImage);
        const canPin = imageUrl && inputType === "keyword" && this.settings.showPinIcon;
        if (checking) return canPin;
        if (canPin) {
          setTimeout(() => handlePinIconClick(imageUrl, this, usedField), 0);
        }
        return true;
      }
    });
    this.addCommand({
      id: "refresh-banner-image",
      name: "\u{1F504} Refresh current banner image",
      checkCallback: (checking) => {
        var _a;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!activeView || !activeView.file) return false;
        const frontmatter = (_a = this.app.metadataCache.getFileCache(activeView.file)) == null ? void 0 : _a.frontmatter;
        let bannerImage;
        for (const field of this.settings.customBannerField) {
          if (frontmatter == null ? void 0 : frontmatter[field]) {
            bannerImage = frontmatter[field];
            break;
          }
        }
        const inputType = this.getInputType(bannerImage);
        const canRefresh = inputType === "keyword" && this.settings.showPinIcon && this.settings.showRefreshIcon;
        if (checking) return canRefresh;
        if (canRefresh) {
          this.loadedImages.delete(activeView.file.path);
          this.lastKeywords.delete(activeView.file.path);
          this.updateBanner(activeView, true).then(() => {
            new import_obsidian3.Notice("\u{1F504} Refreshed banner image");
          }).catch((error) => {
            console.error("Error refreshing image:", error);
            new import_obsidian3.Notice("\u{1F62D} Failed to refresh image");
          });
        }
        return true;
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-change", async (editor) => {
        var _a;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!activeView || !activeView.file) return;
        const currentFrontmatter = (_a = this.app.metadataCache.getFileCache(activeView.file)) == null ? void 0 : _a.frontmatter;
        if (!currentFrontmatter || !currentFrontmatter.hasOwnProperty("pixel-banner") && !currentFrontmatter.hasOwnProperty("pixel-banner-query")) {
          return;
        }
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        if (!line.includes("pixel-banner") && !line.includes("pixel-banner-query")) {
          return;
        }
        await this.updateBanner(activeView, true);
      })
    );
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.migrateCustomFields();
    if (!Array.isArray(this.settings.folderImages)) {
      this.settings.folderImages = [];
    }
    if (this.settings.folderImages) {
      this.settings.folderImages.forEach((folderImage) => {
        folderImage.imageDisplay = folderImage.imageDisplay || "cover";
        folderImage.imageRepeat = folderImage.imageRepeat || false;
        folderImage.directChildrenOnly = folderImage.directChildrenOnly || false;
      });
    }
  }
  migrateCustomFields() {
    const fieldsToMigrate = [
      "customBannerField",
      "customYPositionField",
      "customContentStartField",
      "customImageDisplayField",
      "customImageRepeatField"
    ];
    fieldsToMigrate.forEach((field) => {
      if (typeof this.settings[field] === "string") {
        console.log(`converting ${field} to array`);
        this.settings[field] = [this.settings[field]];
      } else if (!Array.isArray(this.settings[field])) {
        console.log(`setting default value for ${field}`);
        this.settings[field] = DEFAULT_SETTINGS[field];
      }
    });
    this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.loadedImages.clear();
    this.lastKeywords.clear();
    this.imageCache.clear();
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian3.MarkdownView) {
        this.updateBanner(leaf.view, true);
        if (this.settings.hidePixelBannerFields) {
          this.updateFieldVisibility(leaf.view);
        }
      }
    });
  }
  async handleActiveLeafChange(leaf) {
    const previousLeaf = this.app.workspace.activeLeaf;
    if (previousLeaf && previousLeaf.view instanceof import_obsidian3.MarkdownView) {
      const previousContentEl = previousLeaf.view.contentEl;
      previousContentEl.classList.remove("pixel-banner");
      ["cm-sizer", "markdown-preview-sizer"].forEach((selector) => {
        const container = previousContentEl.querySelector(`.${selector}`);
        if (container) {
          const previousBanner = container.querySelector(".pixel-banner-image");
          if (previousBanner) {
            previousBanner.style.backgroundImage = "";
            previousBanner.style.display = "none";
            if (previousLeaf.view.file) {
              const existingUrl = this.loadedImages.get(previousLeaf.view.file.path);
              if (existingUrl == null ? void 0 : existingUrl.startsWith("blob:")) {
                URL.revokeObjectURL(existingUrl);
              }
              this.loadedImages.delete(previousLeaf.view.file.path);
            }
          }
        }
      });
    }
    if (leaf && leaf.view instanceof import_obsidian3.MarkdownView && leaf.view.file) {
      await this.updateBanner(leaf.view, false);
    }
  }
  handleLayoutChange() {
    setTimeout(() => {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && (activeLeaf.view instanceof import_obsidian3.MarkdownView || activeLeaf.view.getViewType() === "markdown")) {
        this.updateBanner(activeLeaf.view, false);
      }
    }, 100);
  }
  async handleModeChange(leaf) {
    if (leaf && leaf.view instanceof import_obsidian3.MarkdownView && leaf.view.file) {
      await this.updateBanner(leaf.view, true);
      if (this.settings.hidePixelBannerFields) {
        this.updateFieldVisibility(leaf.view);
      }
    }
  }
  async updateBanner(view, isContentChange) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    if (!view || !view.file) {
      return;
    }
    const frontmatter = (_a = this.app.metadataCache.getFileCache(view.file)) == null ? void 0 : _a.frontmatter;
    const contentEl = view.contentEl;
    const isEmbedded = contentEl.classList.contains("internal-embed");
    const existingBanner = contentEl.querySelector(".pixel-banner-image");
    const folderSpecific = this.getFolderSpecificImage(view.file.path);
    let bannerImage = getFrontmatterValue(frontmatter, this.settings.customBannerField) || (folderSpecific == null ? void 0 : folderSpecific.image);
    if (!isEmbedded && !bannerImage) {
      contentEl.classList.remove("pixel-banner");
      if (existingBanner) {
        existingBanner.style.backgroundImage = "";
        existingBanner.style.display = "none";
      }
    }
    if (isContentChange) {
      this.loadedImages.delete(view.file.path);
      this.lastKeywords.delete(view.file.path);
    }
    let yPosition = (_b = folderSpecific == null ? void 0 : folderSpecific.yPosition) != null ? _b : this.settings.yPosition;
    let contentStartPosition = (_c = folderSpecific == null ? void 0 : folderSpecific.contentStartPosition) != null ? _c : this.settings.contentStartPosition;
    if (bannerImage) {
      if (Array.isArray(bannerImage)) {
        bannerImage = bannerImage.flat()[0];
        bannerImage = `[[${bannerImage}]]`;
      }
      if (typeof bannerImage === "string" && !bannerImage.startsWith("[[")) {
        const bannerValues = bannerImage.includes(",") ? bannerImage.split(",").map((v) => v.trim()).filter((v) => v.length > 0).filter(Boolean) : [bannerImage];
        if (bannerValues.length > 0) {
          bannerImage = bannerValues[Math.floor(Math.random() * bannerValues.length)];
        } else {
          bannerImage = null;
        }
      }
      if (bannerImage && !bannerImage.startsWith("[[") && !bannerImage.startsWith("http")) {
        const file = this.app.vault.getAbstractFileByPath(bannerImage);
        if (file && "extension" in file) {
          if (file.extension.match(/^(jpg|jpeg|png|gif|bmp|svg)$/i)) {
            bannerImage = `[[${bannerImage}]]`;
          }
        }
      }
    }
    let imageDisplay = getFrontmatterValue(frontmatter, this.settings.customImageDisplayField) || (folderSpecific == null ? void 0 : folderSpecific.imageDisplay) || this.settings.imageDisplay;
    let imageRepeat = (_e = (_d = getFrontmatterValue(frontmatter, this.settings.customImageRepeatField)) != null ? _d : folderSpecific == null ? void 0 : folderSpecific.imageRepeat) != null ? _e : this.settings.imageRepeat;
    let bannerHeight = (_g = (_f = getFrontmatterValue(frontmatter, this.settings.customBannerHeightField)) != null ? _f : folderSpecific == null ? void 0 : folderSpecific.bannerHeight) != null ? _g : this.settings.bannerHeight;
    let fade = (_i = (_h = getFrontmatterValue(frontmatter, this.settings.customFadeField)) != null ? _h : folderSpecific == null ? void 0 : folderSpecific.fade) != null ? _i : this.settings.fade;
    let borderRadius = (_k = (_j = getFrontmatterValue(frontmatter, this.settings.customBorderRadiusField)) != null ? _j : folderSpecific == null ? void 0 : folderSpecific.borderRadius) != null ? _k : this.settings.borderRadius;
    if (bannerImage) {
      await this.addPixelBanner(contentEl, {
        frontmatter,
        file: view.file,
        isContentChange,
        yPosition,
        contentStartPosition,
        bannerImage,
        imageDisplay,
        imageRepeat,
        bannerHeight,
        fade,
        borderRadius,
        isReadingView: view.getMode && view.getMode() === "preview"
      });
      this.lastYPositions.set(view.file.path, yPosition);
    } else if (existingBanner) {
      existingBanner.style.display = "none";
    }
    if (!isEmbedded) {
      const embeddedNotes = contentEl.querySelectorAll(".internal-embed");
      for (const embed of embeddedNotes) {
        const embedFile = this.app.metadataCache.getFirstLinkpathDest(embed.getAttribute("src"), "");
        if (embedFile) {
          const embedView = {
            file: embedFile,
            contentEl: embed,
            getMode: () => "preview"
          };
          await this.updateBanner(embedView, false);
        }
      }
    }
    if (this.settings.hidePixelBannerFields && view.getMode() === "preview") {
      this.updateFieldVisibility(view);
    }
  }
  setupMutationObserver() {
    this.observer = new MutationObserver((mutations) => {
      for (let mutation of mutations) {
        if (mutation.type === "childList") {
          const removedNodes = Array.from(mutation.removedNodes);
          const addedNodes = Array.from(mutation.addedNodes);
          const bannerRemoved = removedNodes.some(
            (node) => node.classList && node.classList.contains("pixel-banner-image")
          );
          const contentChanged = addedNodes.some(
            (node) => node.nodeType === Node.ELEMENT_NODE && (node.classList.contains("markdown-preview-section") || node.classList.contains("cm-content"))
          );
          if (bannerRemoved || contentChanged) {
            const activeLeaf = this.app.workspace.activeLeaf;
            if (activeLeaf && activeLeaf.view instanceof import_obsidian3.MarkdownView) {
              const contentEl = activeLeaf.view.contentEl;
              const hasBanner = contentEl.querySelector('.pixel-banner-image[style*="display: block"]');
              if (!hasBanner) {
                contentEl.classList.remove("pixel-banner");
              }
            }
            this.debouncedEnsureBanner();
          }
        }
      }
    });
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  getFolderSpecificImage(filePath) {
    const folderPath = this.getFolderPath(filePath);
    const sortedFolderImages = [...this.settings.folderImages].sort(
      (a, b) => {
        var _a, _b;
        return (((_a = b.folder) == null ? void 0 : _a.length) || 0) - (((_b = a.folder) == null ? void 0 : _b.length) || 0);
      }
    );
    for (const folderImage of sortedFolderImages) {
      if (!folderImage.folder) continue;
      if (folderImage.folder === "/") {
        if (folderImage.directChildrenOnly) {
          if (!filePath.includes("/")) {
            return this.createFolderImageSettings(folderImage);
          }
        } else {
          return this.createFolderImageSettings(folderImage);
        }
        continue;
      }
      const normalizedFolderPath = folderImage.folder.startsWith("/") ? folderImage.folder : "/" + folderImage.folder;
      const normalizedFileFolderPath = "/" + folderPath;
      if (folderImage.directChildrenOnly) {
        if (normalizedFileFolderPath === normalizedFolderPath) {
          return this.createFolderImageSettings(folderImage);
        }
      } else {
        if (normalizedFileFolderPath.startsWith(normalizedFolderPath)) {
          return this.createFolderImageSettings(folderImage);
        }
      }
    }
    return null;
  }
  // Helper method to create folder image settings object
  createFolderImageSettings(folderImage) {
    var _a, _b, _c, _d, _e, _f, _g;
    return {
      image: folderImage.image,
      yPosition: (_a = folderImage.yPosition) != null ? _a : this.settings.yPosition,
      contentStartPosition: (_b = folderImage.contentStartPosition) != null ? _b : this.settings.contentStartPosition,
      imageDisplay: (_c = folderImage.imageDisplay) != null ? _c : this.settings.imageDisplay,
      imageRepeat: (_d = folderImage.imageRepeat) != null ? _d : this.settings.imageRepeat,
      bannerHeight: (_e = folderImage.bannerHeight) != null ? _e : this.settings.bannerHeight,
      fade: (_f = folderImage.fade) != null ? _f : this.settings.fade,
      borderRadius: (_g = folderImage.borderRadius) != null ? _g : this.settings.borderRadius
    };
  }
  getFolderPath(filePath) {
    if (!filePath.includes("/")) {
      return "/";
    }
    const lastSlashIndex = filePath.lastIndexOf("/");
    return lastSlashIndex !== -1 ? filePath.substring(0, lastSlashIndex) : "";
  }
  async getImageUrl(type, input) {
    if (type === "url" || type === "path") {
      return input;
    }
    if (type === "obsidianLink") {
      const file = this.getPathFromObsidianLink(input);
      if (file) {
        return this.getVaultImageUrl(file.path);
      }
      return null;
    }
    if (type === "vaultPath") {
      return this.getVaultImageUrl(input);
    }
    if (type === "keyword") {
      const keywords = input.includes(",") ? input.split(",").map((k) => k.trim()).filter((k) => k.length > 0).filter(Boolean) : [input];
      if (keywords.length > 0) {
        const selectedKeyword = keywords[Math.floor(Math.random() * keywords.length)];
        const provider = this.getActiveApiProvider();
        if (provider === "pexels") {
          return this.fetchPexelsImage(selectedKeyword);
        } else if (provider === "pixabay") {
          return this.fetchPixabayImage(selectedKeyword);
        } else if (provider === "flickr") {
          return this.fetchFlickrImage(selectedKeyword);
        } else if (provider === "unsplash") {
          return this.fetchUnsplashImage(selectedKeyword);
        }
      }
      return null;
    }
    return null;
  }
  async fetchPexelsImage(keyword) {
    const apiKey = this.settings.pexelsApiKey;
    if (!apiKey) {
      new import_obsidian3.Notice("Pexels API key is not set. Please set it in the plugin settings.");
      return null;
    }
    const now = Date.now();
    if (now - this.rateLimiter.lastRequestTime < this.rateLimiter.minInterval) {
      await new Promise((resolve) => setTimeout(resolve, this.rateLimiter.minInterval));
    }
    this.rateLimiter.lastRequestTime = Date.now();
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const fallbackKeyword = defaultKeywords[Math.floor(Math.random() * defaultKeywords.length)];
    const keywords = [keyword, fallbackKeyword];
    for (const currentKeyword of keywords) {
      try {
        const response = await (0, import_obsidian3.requestUrl)({
          url: `https://api.pexels.com/v1/search?query=${encodeURIComponent(currentKeyword)}&per_page=${this.settings.numberOfImages}&size=${this.settings.imageSize}&orientation=${this.settings.imageOrientation}`,
          method: "GET",
          headers: {
            "Authorization": apiKey
          }
        });
        if (response.status !== 200) {
          console.error("Failed to fetch images:", response.status, response.text);
          continue;
        }
        const data = response.json;
        if (data.photos && data.photos.length > 0) {
          const randomIndex = Math.floor(Math.random() * data.photos.length);
          if (currentKeyword !== keyword) {
            console.log(`No image found for "${keyword}". Using image for "${currentKeyword}" instead.`);
          }
          const imageUrl = data.photos[randomIndex].src[this.settings.imageSize];
          try {
            await this.preloadImage(imageUrl);
          } catch (error) {
            console.error(`Failed to preload image: ${error.message}`);
          }
          return imageUrl;
        } else if (currentKeyword === keyword) {
          console.log(`No image found for the provided keyword: "${keyword}". Trying a random default keyword.`);
        }
      } catch (error) {
        console.error(`Error fetching image from API for keyword "${currentKeyword}":`, error);
        new import_obsidian3.Notice(`Failed to fetch image: ${error.message}`);
      }
    }
    console.error("No images found for any keywords, including the random default.");
    return null;
  }
  async fetchPixabayImage(keyword) {
    const apiKey = this.settings.pixabayApiKey;
    if (!apiKey) {
      new import_obsidian3.Notice("Pixabay API key is not set. Please set it in the plugin settings.");
      return null;
    }
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const keywordsToTry = [keyword, ...defaultKeywords];
    const maxAttempts = 4;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const currentKeyword = attempt === 0 ? keyword : keywordsToTry[Math.floor(Math.random() * keywordsToTry.length)];
      const apiUrl = "https://pixabay.com/api/";
      const params = new URLSearchParams({
        key: apiKey,
        q: encodeURIComponent(currentKeyword),
        image_type: "photo",
        per_page: this.settings.numberOfImages,
        safesearch: true
      });
      try {
        const response = await this.makeRequest(`${apiUrl}?${params}`);
        if (response.status !== 200) {
          console.error(`Pixabay API error: ${response.status} ${response.statusText}`);
          continue;
        }
        let data;
        if (response.arrayBuffer) {
          const text = new TextDecoder().decode(response.arrayBuffer);
          try {
            data = JSON.parse(text);
          } catch (error) {
            console.error("Failed to parse Pixabay response:", error);
            continue;
          }
        } else {
          console.error("Unexpected response format:", response);
          continue;
        }
        if (data.hits && data.hits.length > 0) {
          const imageUrls = data.hits.map((hit) => hit.largeImageURL);
          if (imageUrls.length > 0) {
            const randomIndex = Math.floor(Math.random() * imageUrls.length);
            const selectedImageUrl = imageUrls[randomIndex];
            return selectedImageUrl;
          }
        }
        console.log(`No images found for keyword: ${currentKeyword}`);
      } catch (error) {
        console.error("Error fetching image from Pixabay:", error);
      }
    }
    console.error("No images found after all attempts");
    new import_obsidian3.Notice("Failed to fetch an image after multiple attempts, try a different keyword and/or update the backup keyword list in settings.");
    return null;
  }
  async fetchFlickrImage(keyword) {
    const apiKey = this.settings.flickrApiKey;
    if (!apiKey) {
      new import_obsidian3.Notice("Flickr API key is not set. Please set it in the plugin settings.");
      return null;
    }
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const keywordsToTry = [keyword, ...defaultKeywords];
    const maxAttempts = 4;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const currentKeyword = attempt === 0 ? keyword : keywordsToTry[Math.floor(Math.random() * keywordsToTry.length)];
      try {
        const searchUrl = `https://www.flickr.com/services/rest/?method=flickr.photos.search&api_key=${apiKey}&text=${encodeURIComponent(currentKeyword)}&per_page=${this.settings.numberOfImages}&format=json&nojsoncallback=1&sort=relevance&content_type=1&media=photos&safe_search=1`;
        const response = await this.makeRequest(searchUrl);
        if (response.status !== 200) {
          console.error(`Flickr API error: ${response.status} ${response.statusText}`);
          continue;
        }
        const data = JSON.parse(new TextDecoder().decode(response.arrayBuffer));
        if (data.stat !== "ok") {
          console.error("Flickr API error:", data);
          continue;
        }
        if (data.photos && data.photos.photo && data.photos.photo.length > 0) {
          const photos = data.photos.photo;
          const randomIndex = Math.floor(Math.random() * photos.length);
          const photo = photos[randomIndex];
          let size = "z";
          switch (this.settings.imageSize) {
            case "small":
              size = "n";
              break;
            // Small 320
            case "medium":
              size = "z";
              break;
            // Medium 640
            case "large":
              size = "b";
              break;
          }
          const imageUrl = `https://live.staticflickr.com/${photo.server}/${photo.id}_${photo.secret}_${size}.jpg`;
          return imageUrl;
        }
        console.log(`No images found for keyword: ${currentKeyword}`);
      } catch (error) {
        console.error("Error fetching image from Flickr:", error);
      }
    }
    console.error("No images found after all attempts");
    new import_obsidian3.Notice("Failed to fetch an image after multiple attempts");
    return null;
  }
  async fetchUnsplashImage(keyword) {
    const apiKey = this.settings.unsplashApiKey;
    if (!apiKey) {
      new import_obsidian3.Notice("Unsplash API key is not set. Please set it in the plugin settings.");
      return null;
    }
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const keywordsToTry = [keyword, ...defaultKeywords];
    const maxAttempts = 4;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const currentKeyword = attempt === 0 ? keyword : keywordsToTry[Math.floor(Math.random() * keywordsToTry.length)];
      try {
        let apiUrl = "https://api.unsplash.com/search/photos";
        const params = new URLSearchParams({
          query: currentKeyword,
          per_page: this.settings.numberOfImages,
          orientation: this.settings.imageOrientation
        });
        const response = await this.makeRequest(`${apiUrl}?${params}`, {
          headers: {
            "Authorization": `Client-ID ${apiKey}`,
            "Accept-Version": "v1"
          }
        });
        if (response.status !== 200) {
          console.error(`Unsplash API error: ${response.status}`);
          continue;
        }
        const data = JSON.parse(new TextDecoder().decode(response.arrayBuffer));
        if (!data.results || data.results.length === 0) {
          console.log(`No images found for keyword: ${currentKeyword}`);
          continue;
        }
        const randomIndex = Math.floor(Math.random() * data.results.length);
        const photo = data.results[randomIndex];
        let imageUrl;
        switch (this.settings.imageSize) {
          case "small":
            imageUrl = photo.urls.small;
            break;
          case "medium":
            imageUrl = photo.urls.regular;
            break;
          case "large":
            imageUrl = photo.urls.full;
            break;
          default:
            imageUrl = photo.urls.regular;
        }
        return imageUrl;
      } catch (error) {
        console.error("Error fetching image from Unsplash:", error);
      }
    }
    console.error("No images found after all attempts");
    new import_obsidian3.Notice("Failed to fetch an image after multiple attempts");
    return null;
  }
  async makeRequest(url, options = {}) {
    const now = Date.now();
    if (now - this.rateLimiter.lastRequestTime < this.rateLimiter.minInterval) {
      await new Promise((resolve) => setTimeout(resolve, this.rateLimiter.minInterval));
    }
    this.rateLimiter.lastRequestTime = Date.now();
    try {
      const response = await (0, import_obsidian3.requestUrl)({
        url,
        headers: options.headers || {},
        ...options
      });
      return response;
    } catch (error) {
      console.error("Request failed:", error);
      throw new Error(`Request failed: ${error.message}`);
    }
  }
  preloadImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(url);
      img.onerror = reject;
      img.src = url;
    });
  }
  getInputType(input) {
    if (Array.isArray(input)) {
      input = input.flat()[0];
    }
    if (typeof input !== "string") {
      return "invalid";
    }
    input = input.trim().replace(/^["'](.*)["']$/, "$1");
    if (input.match(/^\[{2}.*\]{2}$/) || input.match(/^"?\[{2}.*\]{2}"?$/)) {
      return "obsidianLink";
    }
    try {
      new URL(input);
      return "url";
    } catch (_) {
      const file = this.app.vault.getAbstractFileByPath(input);
      if (file && "extension" in file) {
        if (file.extension.match(/^(jpg|jpeg|png|gif|bmp|svg)$/i)) {
          return "vaultPath";
        }
      }
      return "keyword";
    }
  }
  getPathFromObsidianLink(link) {
    let innerLink = link.startsWith("[[") ? link.slice(2) : link;
    innerLink = innerLink.endsWith("]]") ? innerLink.slice(0, -2) : innerLink;
    const path = innerLink.split("|")[0];
    return this.app.metadataCache.getFirstLinkpathDest(path, "");
  }
  async getVaultImageUrl(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && "extension" in file) {
      try {
        const arrayBuffer = await this.app.vault.readBinary(file);
        const blob = new Blob([arrayBuffer], { type: `image/${file.extension}` });
        const url = URL.createObjectURL(blob);
        return url;
      } catch (error) {
        console.error("Error reading vault image:", error);
        return null;
      }
    }
    return null;
  }
  updateAllBanners() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() === "markdown") {
        this.updateBanner(leaf.view, true);
      }
    });
  }
  async postProcessor(el, ctx) {
    const frontmatter = ctx.frontmatter;
    if (frontmatter && frontmatter[this.settings.customBannerField]) {
      await this.addPixelBanner(el, {
        frontmatter,
        file: ctx.sourcePath,
        isContentChange: false,
        yPosition: frontmatter[this.settings.customYPositionField] || this.settings.yPosition,
        contentStartPosition: frontmatter[this.settings.customContentStartField] || this.settings.contentStartPosition,
        customBannerField: this.settings.customBannerField,
        customYPositionField: this.settings.customYPositionField,
        customContentStartField: this.settings.customContentStartField,
        customImageDisplayField: this.settings.customImageDisplayField,
        customImageRepeatField: this.settings.customImageRepeatField,
        bannerImage: frontmatter[this.settings.customBannerField]
      });
      if (this.settings.hidePixelBannerFields) {
        const frontmatterEl = el.querySelector(".frontmatter");
        if (frontmatterEl) {
          const fieldsToHide = [
            ...this.settings.customBannerField,
            ...this.settings.customYPositionField,
            ...this.settings.customContentStartField,
            ...this.settings.customImageDisplayField,
            ...this.settings.customImageRepeatField,
            ...this.settings.customBannerHeightField,
            ...this.settings.customFadeField,
            ...this.settings.customBorderRadiusField
          ];
          const rows = frontmatterEl.querySelectorAll(".frontmatter-container .frontmatter-section-label");
          rows.forEach((row) => {
            const label = row.textContent.replace(":", "").trim();
            if (fieldsToHide.includes(label)) {
              row.closest(".frontmatter-section").classList.add("pixel-banner-hidden-field");
            }
          });
        }
      }
    }
  }
  onunload() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
  applyContentStartPosition(el, contentStartPosition) {
    if (!el) {
      return;
    }
    el.style.setProperty("--pixel-banner-content-start", `${contentStartPosition}px`);
  }
  getFolderSpecificSetting(filePath, settingName) {
    var _a;
    const folderPath = this.getFolderPath(filePath);
    for (const folderImage of this.settings.folderImages) {
      if (folderPath.startsWith(folderImage.folder)) {
        return (_a = folderImage[settingName]) != null ? _a : void 0;
      }
    }
    return void 0;
  }
  async cleanOrphanedPins() {
    var _a;
    const vault = this.app.vault;
    const folderPath = this.settings.pinnedImageFolder;
    let cleaned = 0;
    try {
      if (!await vault.adapter.exists(folderPath)) {
        return { cleaned };
      }
      const pinnedFolder = vault.getAbstractFileByPath(folderPath);
      if (!pinnedFolder || !pinnedFolder.children) {
        return { cleaned };
      }
      const imageExtensions = ["png", "jpg", "jpeg", "gif", "bmp", "webp", "svg"];
      const pinnedImages = pinnedFolder.children.filter((file) => imageExtensions.includes(file.extension.toLowerCase())).map((file) => file.path);
      if (!pinnedImages.length) {
        return { cleaned };
      }
      const markdownFiles = this.app.vault.getMarkdownFiles();
      const bannerFields = this.settings.customBannerField;
      const referencedImages = /* @__PURE__ */ new Set();
      for (const file of markdownFiles) {
        const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        if (frontmatter) {
          for (const field of bannerFields) {
            const bannerValue = frontmatter[field];
            if (bannerValue && typeof bannerValue === "string") {
              const cleanPath = bannerValue.replace(/[\[\]]/g, "").trim();
              referencedImages.add(cleanPath);
            }
          }
        }
      }
      for (const imagePath of pinnedImages) {
        if (!referencedImages.has(imagePath)) {
          await vault.trash(vault.getAbstractFileByPath(imagePath), true);
          cleaned++;
        }
      }
      return { cleaned };
    } catch (error) {
      console.error("Error in cleanOrphanedPins:", error);
      throw error;
    }
  }
  async checkVersion() {
    const currentVersion = this.manifest.version;
    const lastVersion = this.settings.lastVersion;
    if (this.settings.showReleaseNotes && (!lastVersion || lastVersion !== currentVersion)) {
      const releaseNotes2 = await this.getReleaseNotes(currentVersion);
      new ReleaseNotesModal(this.app, currentVersion, releaseNotes2).open();
      this.settings.lastVersion = currentVersion;
      await this.saveSettings();
    }
  }
  async getReleaseNotes(version) {
    return releaseNotes;
  }
  async addPixelBanner(el, ctx) {
    var _a, _b;
    const { frontmatter, file, isContentChange, yPosition, contentStartPosition, bannerImage, isReadingView } = ctx;
    const viewContent = el;
    const isEmbedded = viewContent.classList.contains("internal-embed");
    if (!isEmbedded) {
      viewContent.classList.add("pixel-banner");
    }
    let container;
    if (isEmbedded) {
      container = viewContent.querySelector(".markdown-preview-sizer");
      if (!container) {
        container = viewContent.querySelector(".markdown-embed-content");
      }
      if (!container) {
        container = viewContent;
      }
    } else {
      container = isReadingView ? viewContent.querySelector(".markdown-preview-sizer:not(.internal-embed .markdown-preview-sizer)") : viewContent.querySelector(".cm-sizer");
    }
    if (!container) {
      return;
    }
    let bannerDiv = container.querySelector(":scope > .pixel-banner-image");
    let pinIcon = container.querySelector(":scope > .pin-icon");
    if (!bannerDiv) {
      bannerDiv = createDiv({ cls: "pixel-banner-image" });
      container.insertBefore(bannerDiv, container.firstChild);
      bannerDiv._isPersistentBanner = true;
      if (!isEmbedded && this.settings.showPinIcon) {
        pinIcon = createDiv({ cls: "pin-icon" });
        pinIcon.style.position = "absolute";
        pinIcon.style.top = "10px";
        pinIcon.style.left = "5px";
        pinIcon.style.fontSize = "1.5em";
        pinIcon.style.cursor = "pointer";
        pinIcon.innerHTML = "\u{1F4CC}";
        pinIcon._isPersistentPin = true;
        container.insertBefore(pinIcon, bannerDiv.nextSibling);
        if (this.settings.showRefreshIcon) {
          const refreshIcon = createDiv({ cls: "refresh-icon" });
          refreshIcon.style.position = "absolute";
          refreshIcon.style.top = "10px";
          refreshIcon.style.left = "40px";
          refreshIcon.style.fontSize = "1.5em";
          refreshIcon.style.cursor = "pointer";
          refreshIcon.innerHTML = "\u{1F504}";
          refreshIcon._isPersistentRefresh = true;
          container.insertBefore(refreshIcon, pinIcon.nextSibling);
        }
      }
    }
    if (!container._hasOverriddenSetChildrenInPlace) {
      const originalSetChildrenInPlace = container.setChildrenInPlace;
      container.setChildrenInPlace = function(children) {
        const bannerElement = this.querySelector(":scope > .pixel-banner-image");
        const pinElement = this.querySelector(":scope > .pin-icon");
        const refreshElement = this.querySelector(":scope > .refresh-icon");
        children = Array.from(children);
        if (bannerElement == null ? void 0 : bannerElement._isPersistentBanner) {
          children = [bannerElement, ...children];
        }
        if (pinElement == null ? void 0 : pinElement._isPersistentPin) {
          children.splice(1, 0, pinElement);
        }
        if (refreshElement == null ? void 0 : refreshElement._isPersistentRefresh) {
          children.splice(2, 0, refreshElement);
        }
        originalSetChildrenInPlace.call(this, children);
      };
      container._hasOverriddenSetChildrenInPlace = true;
    }
    if (bannerImage) {
      let imageUrl = this.loadedImages.get(file.path);
      const lastInput = this.lastKeywords.get(file.path);
      const inputType = this.getInputType(bannerImage);
      if (!imageUrl || isContentChange && bannerImage !== lastInput) {
        imageUrl = await this.getImageUrl(inputType, bannerImage);
        if (imageUrl) {
          this.loadedImages.set(file.path, imageUrl);
          this.lastKeywords.set(file.path, bannerImage);
        }
      }
      if (imageUrl) {
        const frontmatterYPosition = getFrontmatterValue(frontmatter, this.settings.customYPositionField);
        const folderSpecific = this.getFolderSpecificImage(file.path);
        const effectiveYPosition = (_a = frontmatterYPosition != null ? frontmatterYPosition : folderSpecific == null ? void 0 : folderSpecific.yPosition) != null ? _a : this.settings.yPosition;
        bannerDiv.style.backgroundImage = `url('${imageUrl}')`;
        bannerDiv.style.backgroundPosition = `center ${effectiveYPosition}%`;
        bannerDiv.style.display = "block";
        this.applyBannerSettings(bannerDiv, ctx);
        const frontmatterContentStart = getFrontmatterValue(frontmatter, this.settings.customContentStartField);
        const effectiveContentStart = (_b = frontmatterContentStart != null ? frontmatterContentStart : folderSpecific == null ? void 0 : folderSpecific.contentStartPosition) != null ? _b : this.settings.contentStartPosition;
        this.applyContentStartPosition(viewContent, effectiveContentStart);
        if (!isEmbedded && inputType === "keyword" && this.settings.showPinIcon) {
          const refreshIcon = container.querySelector(":scope > .refresh-icon");
          if (pinIcon) {
            pinIcon.style.display = "block";
            pinIcon.onclick = async () => {
              try {
                let usedField;
                for (const field of this.settings.customBannerField) {
                  if (frontmatter == null ? void 0 : frontmatter[field]) {
                    usedField = field;
                    break;
                  }
                }
                await handlePinIconClick(imageUrl, this, usedField);
              } catch (error) {
                console.error("Error pinning image:", error);
                new import_obsidian3.Notice("\u{1F62D} Failed to pin the image.");
              }
            };
          }
          if (refreshIcon && this.settings.showRefreshIcon) {
            refreshIcon.style.display = "block";
            refreshIcon.onclick = async () => {
              try {
                this.loadedImages.delete(file.path);
                this.lastKeywords.delete(file.path);
                await this.updateBanner(this.app.workspace.activeLeaf.view, true);
                new import_obsidian3.Notice("\u{1F504} Refreshed banner image");
              } catch (error) {
                console.error("Error refreshing image:", error);
                new import_obsidian3.Notice("\u{1F62D} Failed to refresh image");
              }
            };
          }
        } else {
          if (pinIcon) pinIcon.style.display = "none";
          const refreshIcon = container.querySelector(":scope > .refresh-icon");
          if (refreshIcon) refreshIcon.style.display = "none";
        }
      } else {
        bannerDiv.style.display = "none";
        if (pinIcon) pinIcon.style.display = "none";
        const refreshIcon = container.querySelector(":scope > .refresh-icon");
        if (refreshIcon) refreshIcon.style.display = "none";
        this.loadedImages.delete(file.path);
        this.lastKeywords.delete(file.path);
        if (!isEmbedded) {
          viewContent.classList.remove("pixel-banner");
        }
      }
    }
  }
  applyBannerSettings(bannerDiv, ctx) {
    const { frontmatter, imageDisplay, imageRepeat, bannerHeight, fade, borderRadius } = ctx;
    bannerDiv.style.backgroundSize = imageDisplay || "cover";
    bannerDiv.style.backgroundRepeat = imageRepeat ? "repeat" : "no-repeat";
    bannerDiv.style.setProperty("--pixel-banner-height", `${bannerHeight}px`);
    bannerDiv.style.setProperty("--pixel-banner-fade", `${fade}%`);
    bannerDiv.style.setProperty("--pixel-banner-radius", `${borderRadius}px`);
  }
  // Add this helper method to randomly select an API provider
  getActiveApiProvider() {
    if (this.settings.apiProvider !== "all") {
      return this.settings.apiProvider;
    }
    const availableProviders = [];
    if (this.settings.pexelsApiKey) availableProviders.push("pexels");
    if (this.settings.pixabayApiKey) availableProviders.push("pixabay");
    if (this.settings.flickrApiKey) availableProviders.push("flickr");
    if (this.settings.unsplashApiKey) availableProviders.push("unsplash");
    if (availableProviders.length === 0) {
      return "pexels";
    }
    return availableProviders[Math.floor(Math.random() * availableProviders.length)];
  }
  // Add this new method to handle field visibility
  updateFieldVisibility(view) {
    if (!view || view.getMode() !== "preview") return;
    const fieldsToHide = [
      ...this.settings.customBannerField,
      ...this.settings.customYPositionField,
      ...this.settings.customContentStartField,
      ...this.settings.customImageDisplayField,
      ...this.settings.customImageRepeatField,
      ...this.settings.customBannerHeightField,
      ...this.settings.customFadeField,
      ...this.settings.customBorderRadiusField
    ];
    const propertiesContainer = view.contentEl.querySelector(".metadata-container");
    if (!propertiesContainer) return;
    const propertyElements = propertiesContainer.querySelectorAll(".metadata-property");
    let visiblePropertiesCount = 0;
    let bannerPropertiesCount = 0;
    propertyElements.forEach((propertyEl) => {
      const key = propertyEl.getAttribute("data-property-key");
      if (fieldsToHide.includes(key)) {
        propertyEl.classList.add("pixel-banner-hidden-field");
        bannerPropertiesCount++;
      } else {
        visiblePropertiesCount++;
      }
    });
    if (this.settings.hidePropertiesSectionIfOnlyBanner && this.settings.hidePixelBannerFields && visiblePropertiesCount === 0 && bannerPropertiesCount > 0) {
      propertiesContainer.classList.add("pixel-banner-hidden-section");
    } else {
      propertiesContainer.classList.remove("pixel-banner-hidden-section");
    }
  }
};
function getFrontmatterValue(frontmatter, fieldNames) {
  if (!frontmatter || !Array.isArray(fieldNames)) return void 0;
  for (const fieldName of fieldNames) {
    if (fieldName in frontmatter) {
      const value = frontmatter[fieldName];
      if (typeof value === "string" && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        return value.toLowerCase() === "true";
      }
      return value;
    }
  }
  return void 0;
}
async function handlePinIconClick(imageUrl, plugin, usedField = null) {
  const imageBlob = await fetchImage(imageUrl);
  const { initialPath, file } = await saveImageLocally(imageBlob, plugin);
  const finalPath = await waitForFileRename(file, plugin);
  if (!finalPath) {
    console.error("\u274C Failed to resolve valid file path");
    new import_obsidian3.Notice("Failed to save image - file not found");
    return;
  }
  await updateNoteFrontmatter(finalPath, plugin, usedField);
  hidePinIcon();
}
async function fetchImage(url) {
  const response = await fetch(url);
  if (!response.ok) throw new Error("Image download failed");
  return await response.arrayBuffer();
}
var FolderSelectionModal = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app2, defaultFolder, onChoose) {
    super(app2);
    this.defaultFolder = defaultFolder;
    this.onChoose = onChoose;
    this.setPlaceholder("Select or type folder path to save Pinned Banner Image");
    this.titleEl.setText("Choose Folder to save Pinned Banner Image");
  }
  getItems() {
    return [this.defaultFolder, ...this.app.vault.getAllLoadedFiles().filter((file) => file.children).map((folder) => folder.path)];
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item) {
    this.onChoose(item);
  }
  onOpen() {
    super.onOpen();
    const inputEl = this.inputEl;
    inputEl.value = this.defaultFolder;
    inputEl.select();
    this.updateSuggestions();
  }
};
async function saveImageLocally(arrayBuffer, plugin) {
  const vault = plugin.app.vault;
  const defaultFolderPath = plugin.settings.pinnedImageFolder;
  const folderPath = await new Promise((resolve) => {
    const modal = new FolderSelectionModal(plugin.app, defaultFolderPath, (result) => {
      resolve(result);
    });
    modal.open();
  });
  if (!folderPath) {
    throw new Error("No folder selected");
  }
  if (!await vault.adapter.exists(folderPath)) {
    await vault.createFolder(folderPath);
  }
  const suggestedName = "pixel-banner-image";
  const userInput = await new Promise((resolve) => {
    const modal = new SaveImageModal(plugin.app, suggestedName, (result) => {
      resolve(result);
    });
    modal.open();
  });
  if (!userInput) {
    throw new Error("No filename provided");
  }
  let baseName = userInput.replace(/[^a-zA-Z0-9-_ ]/g, "").trim();
  if (!baseName) baseName = "banner";
  if (!baseName.toLowerCase().endsWith(".png")) baseName += ".png";
  let fileName = baseName;
  let counter = 1;
  while (await vault.adapter.exists(`${folderPath}/${fileName}`)) {
    const nameWithoutExt = baseName.slice(0, -4);
    fileName = `${nameWithoutExt}-${counter}.png`;
    counter++;
  }
  const filePath = `${folderPath}/${fileName}`;
  const savedFile = await vault.createBinary(filePath, arrayBuffer);
  return {
    initialPath: filePath,
    file: savedFile
  };
}
async function updateNoteFrontmatter(imagePath, plugin, usedField = null) {
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) return;
  let fileContent = await app.vault.read(activeFile);
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const hasFrontmatter = frontmatterRegex.test(fileContent);
  const bannerField = usedField || (Array.isArray(plugin.settings.customBannerField) && plugin.settings.customBannerField.length > 0 ? plugin.settings.customBannerField[0] : "banner");
  fileContent = fileContent.replace(/^\s+/, "");
  let updatedContent;
  if (hasFrontmatter) {
    updatedContent = fileContent.replace(frontmatterRegex, (match, frontmatter) => {
      const bannerRegex = new RegExp(`${bannerField}:\\s*.+`);
      let cleanedFrontmatter = frontmatter.trim();
      plugin.settings.customBannerField.forEach((field) => {
        const fieldRegex = new RegExp(`${field}:\\s*.+\\n?`, "g");
        cleanedFrontmatter = cleanedFrontmatter.replace(fieldRegex, "");
      });
      cleanedFrontmatter = cleanedFrontmatter.trim();
      const newFrontmatter = `${bannerField}: ${imagePath}${cleanedFrontmatter ? "\n" + cleanedFrontmatter : ""}`;
      return `---
${newFrontmatter}
---`;
    });
  } else {
    const cleanContent = fileContent.replace(/^\s+/, "");
    updatedContent = `---
${bannerField}: ${imagePath}
---

${cleanContent}`;
  }
  updatedContent = updatedContent.replace(/^\s+/, "");
  if (updatedContent !== fileContent) {
    await app.vault.modify(activeFile, updatedContent);
  }
}
function hidePinIcon() {
  const pinIcon = document.querySelector(".pin-icon");
  if (pinIcon) pinIcon.style.display = "none";
}
var SaveImageModal = class extends import_obsidian3.Modal {
  constructor(app2, suggestedName, onSubmit) {
    super(app2);
    this.suggestedName = suggestedName;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Save Banner Image" });
    const inputContainer = contentEl.createDiv();
    inputContainer.style.margin = "1em 0";
    const input = inputContainer.createEl("input", {
      type: "text",
      value: this.suggestedName
    });
    input.style.width = "100%";
    input.focus();
    input.select();
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "1em";
    buttonContainer.style.marginTop = "1em";
    const submitButton = buttonContainer.createEl("button", {
      text: "Save"
    });
    submitButton.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.onSubmit(input.value);
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.onSubmit(null);
      this.close();
    });
    input.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        event.stopPropagation();
        setTimeout(() => {
          this.onSubmit(input.value);
          this.close();
        }, 0);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
async function waitForFileRename(file, plugin) {
  return new Promise((resolve) => {
    const initialPath = file.path;
    let timeoutId;
    let renamedPath = null;
    const validatePath = async (path) => {
      if (!path) return false;
      return await plugin.app.vault.adapter.exists(path);
    };
    const handleRename = async (theFile) => {
      if (theFile == null ? void 0 : theFile.path) {
        renamedPath = theFile == null ? void 0 : theFile.path;
      }
    };
    const cleanup = () => {
      plugin.app.vault.off("rename", handleRename);
    };
    plugin.app.vault.on("rename", handleRename);
    timeoutId = setTimeout(async () => {
      cleanup();
      if (renamedPath) {
        const exists = await validatePath(renamedPath);
        if (exists) {
          return resolve(renamedPath);
        }
      }
      const initialExists = await validatePath(initialPath);
      if (initialExists) {
        return resolve(initialPath);
      }
      resolve(null);
    }, 1500);
  });
}

/* nosourcemap */